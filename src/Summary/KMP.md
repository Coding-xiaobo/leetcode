**给定一个模式串P和一个主串S，求模式串P在主串S中出现的位置（字符串的下表均从1开始）**

暴力的做法是比较失败，主串从第二个位置重新和模式串进行匹配

**暴力做法的时间复杂度**是两个字符串长度相乘，复杂度很高，浪费了已经比较过的信息

KMP的做法是比较失败，主串原地不动，让模式串回退到恰当的位置，再做比较

就是从前面已经匹配过的信息中，找出来一段，仍然是匹配的，利用匹配过的信息

**next数组**

`next[i]`表示模式串`P[1,i]`中相等前后缀（不包括自身）的最长长度

通过模式串前后缀的自我匹配的长度，计算next数组，给模式串的指针打一张表，失败时就跳到`next[j]`的位置继续匹配

### 暴力模拟
`p = a a b a a b a a a`
```java
//没有前后缀
ne[1] = 0   a                       //没有前后缀
ne[2] = 1   a a                     //有一对前后缀 a a
ne[3] = 0   a a b                   //没有前后缀
ne[4] = 1   a a b a                 //有一对前后缀 a a
ne[5] = 2   a a b a a               //有两对前后缀 a a 和 aa aa
ne[6] = 3   a a b a a b             //有三对前后缀 a a 和 aa aa 和 aab aab
ne[7] = 4   a a b a a b a
ne[8] = 5   a a b a a b a a         //最长的是 a a b a a
ne[9] = 2   a a b a a b a a a
ne[10] = 2  a a b a a b a a a a
```
对于`next[i]` 需要计算 `i - 1`次，那时间复杂度是`O(N ^ 2)`

但是有一定的规律，从`ne[i]`增加都是增加1，减小是从上一步匹配的部分，再找出最长前后缀，比如`ne[8] = 5`，最长匹配是5个，而`ne[9]`就不能增加了，`ne[9]`的值是`ne[8]`求出最长前缀的基础上，在长度为5的字符串中求最长前后缀，所以`ne[9] = 2`

求next数组的方法如下：
```java
ne[1] = 0; 
for(int i = 2, j = 0; i <= n; i++) {
    while(j && P[i] != P[j + 1]) j = ne[j];
    if(P[i] == P[j + 1]) j++;
    ne[i] = j;
}
```
双指针：i扫描模式串，j扫描前缀

初始化，`ne[1] = 0, i = 2, j = 0`

每轮for循环，i向右走一步
1. 若`P[i] != P[j+1]`，让j回跳到能匹配的位置，如果找不到能匹配的位置，j回跳到0
2. 若p[i] == p[j+1]，让j+1，指向匹配匹配前缀的末尾
3. next[i]等于j的值


